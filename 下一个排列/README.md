# 题目
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

    1,2,3 → 1,3,2
    3,2,1 → 1,2,3
    1,1,5 → 1,5,1
# 解题思路
因为字典序是从左向右按照每位比较的，所以下一个排列，应该是从右边向左边找，与第一个比最右边的数字小的数字交换。如果没有，再从次右边找。时间复杂度是o(n2)

这个思路是错误的，对于用例：[1,3,2]，输出结果是：[2,3,1]，然而实际输出结果应为：[2,1,3]。所以不能简单只交换一次，如果延续后面的思路，还需要在交换过后调整使该数字变为最小值。

靠，看了一下题解，就是这个思路……交换完后需要调整该数字右边的数字变成最小的排列。

思路有问题，不是从右向左找第一个小的，而应该是第一个不符合从右向左非严格递增序列的数字。
# 成绩
时间>95.83%，空间>39.94%

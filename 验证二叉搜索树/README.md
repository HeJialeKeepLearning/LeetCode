# 题目
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

    节点的左子树只包含小于当前节点的数。
    节点的右子树只包含大于当前节点的数。
    所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

    输入:
        2
       / \
      1   3
    输出: true
示例 2:

    输入:
        5
       / \
      1   4
         / \
        3   6
    输出: false
    解释: 输入为: [5,1,4,null,null,3,6]。
         根节点的值为 5 ，但是其右子节点值为 4 。

# 解题思路
1. 中序遍历，因为BST=>中序遍历有序，所以中序遍历无序=>非BST。存在漏洞，有没有中序遍历有序，但是不是BST的？
2. 递归对左右子树分别判断，除保证root.left.val < root.val < root.right.val外，还需要保持一个min和max，以避免出现下面这种情况：

            10
            /\
          5   15
              / \
             2   6

最后选择了思路1，思路2并不是简单判断当前值是否和root有关，而要记录。

思路1的时间复杂度：中序遍历o(n)，查看是否满足严格递增列表o(n)，共o(n)，空间复杂度o(n)
# 成绩
时间>87.91%
空间>35.28%

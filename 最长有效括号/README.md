# 题目
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

    输入: "(()"
    输出: 2
    解释: 最长有效括号子串为 "()"
示例 2:

    输入: ")()())"
    输出: 4
    解释: 最长有效括号子串为 "()()"

# 解题思路
本来以为是动规，结果发现是有效括号个数*2？？

不是有效括号个数，如下：

    输入："()(()"
    正确输出：2
如果按照有效括号个数的思路，输出结果是4，但是实际上是2，所以还是用动态规划做

状态dp[n]表示字符串前n个字符的有效括号长度

转移方程：
1. 若s[n] == ')', s[n-1] == '(' :
    - 若dp[-1]和dp[-3]不同, 则dp[n] = 2 + dp[n-2]
    - 若dp[-1]和dp[-3]相同，则dp[n] = 2
2. 否则,dp[n] = 0

初始化dp=[0]，最后输出max(dp)

不对，这样会忽略(())的情况

v2思路：
把所有有效括号都保存出来，然后找其中最长的一个。有效括号：pop后栈的长度没变化，则属于一个有效括号串。

两种思路都是可以的，但是都没有想完全。动态规划的思路，漏掉了(())的情况，v2的思路，其实是需要找所有偶数个子串中的有效串长度的。

动态规划（补充官方题解）思路重写：

状态：dp[n]表示字符串第n位对应的子串长度

转移方程：
1. 若s[n] == ')', s[n-1] == '(', 即形如……(), 则dp[n] = dp[n-2] + 2
2. 若s[n] == ')', s[n-1] == ')', 即形如……)), 则考虑dp[n-1]对应的有效括号前是否还有'('。将dp[n-1]对应的有效括号记为subp,若list[i - subp - 1] == '(',即输入的字符串是(,subp,),那么dp[n] = dp[n-1] + 2 + dp[n - dp[n-1] - 2], 最后一项表示在(,subp,)之前的有效括号数。如果subp前面没有(了，那就dp[n] = 0
3. dp[n] = 0

时间复杂度、空间复杂度均为o(n)
# 总结
动态规划里面，最简单的果然是dp[n] = F(dp[n-1])，其他的比如两个字符串比较的，会涉及到二维数组，这种题目的，dp并不代表子问题的答案，而且状态的转移还不好思考全面，日
# 成绩
时间>76.14%
空间>17.02%
